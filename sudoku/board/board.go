package board

import (
	"fmt"
	"math/rand"
	"strconv"
	"strings"
	"time"
)

const (
	cols                    = 9
	rows                    = 9
	n1                      = "\n"
	TopRight                = "┓"
	TopBoxSeparator         = "┳"
	TopColumnSeparator      = "┯"
	TopLeft                 = "┏"
	VerticalBoxSeparator    = "┃"
	VerticalColumnSeparator = "│"
	BottomRight             = "┛"
	BottomBoxSeparator      = "┻"
	BottonColumnSeparator   = "┷"
	BottomLeft              = "┗"
	HorizontalBoxSeparator  = "━━━"
	HorizontalRowSeparator  = "─"
	LeftBoxSeparator        = "┣"
	LeftRowSeparator        = "┠"
	RightBoxSeparator       = "┫"
	RightRowSeparator       = "┫"
	MiddleBoxSeparator      = "╋"
	MiddleColumnSeparator   = "┼"
	MiddleHybridSeparator   = "┿"
)

type State struct {
	board [9][9]int
}

type positionOutOfBound struct {
	row    int
	column int
}

type valueNotValid struct {
	value int
}

type originalValue struct {
	value int
}

func (e *positionOutOfBound) Error() string {
	return fmt.Sprintf("posistion (%d,%d) is out of bounds...", e.row, e.column)
}

func (e *valueNotValid) Error() string {
	return fmt.Sprintf("value %d is not 1-9", e.value)
}

func (e *originalValue) Error() string {
	return fmt.Sprintf("cannot modify an original value generated by the puzzle...", e.value)
}

func (s *State) PrintBoard() {
	TopBox := strings.Repeat(HorizontalBoxSeparator+BottonColumnSeparator, 2) + HorizontalBoxSeparator + TopBoxSeparator
	TopBar := TopLeft + TopBox + TopRight + n1
	RowBox := strings.Repeat(HorizontalRowSeparator, 3)
	BoxHorizontal := LeftBoxSeparator + HorizontalBoxSeparator + MiddleBoxSeparator
	BottomBox := strings.Repeat(HorizontalBoxSeparator+TopColumnSeparator, 2) + HorizontalBoxSeparator + BottomBoxSeparator
	BottomBar := BottomLeft + BottomBox + BottomRight + n1
	fmt.Printf("%s", TopBar)
	for i := 0; i < rows; i++ {
		completerow := s.getNum(i) + n1
		rowSeparator := LeftRowSeparator + RowBox + VerticalBoxSeparator + n1
		if i == 3 {
			fmt.Print(BoxHorizontal)
		}
		fmt.Print(completerow)
		fmt.Print(rowSeparator)
	}
	fmt.Printf("%s", BottomBar)
}

func (s *State) getNum(row int) string {
	var numbers []int
	i := row
	for j := 0; j < cols; j++ {
		// if s.board[i][j] == 0 {
		// 	numbers[j] == []
		// }
		numbers[j] = s.board[i][j]
	}
	Box1 := " " + strconv.Itoa(numbers[0]) + " " + VerticalColumnSeparator + " " + strconv.Itoa(numbers[1]) + " " + VerticalColumnSeparator + " " + strconv.Itoa(numbers[2]) + " " + VerticalColumnSeparator
	Box2 := " " + strconv.Itoa(numbers[3]) + " " + VerticalColumnSeparator + " " + strconv.Itoa(numbers[4]) + " " + VerticalColumnSeparator + " " + strconv.Itoa(numbers[5]) + " " + VerticalColumnSeparator
	Box3 := " " + strconv.Itoa(numbers[6]) + " " + VerticalColumnSeparator + " " + strconv.Itoa(numbers[7]) + " " + VerticalColumnSeparator + " " + strconv.Itoa(numbers[8]) + " "
	completerow := VerticalBoxSeparator + Box1 + Box2 + Box3 + VerticalBoxSeparator
	return completerow
}

func (s *State) generateEmpty() {

	for i := 0; i < rows; i++ {
		for j := 0; j < cols; j++ {
			s.board[i][j] = 0
		}

	}
}

func generateNum() int {
	number_list := [9]int{1, 2, 3, 4, 5, 6, 7, 8, 9}
	rand.Seed(time.Now().UnixNano())
	rlength := len(number_list)
	randomIndex := rand.Intn(rlength - 1)
	num := number_list[randomIndex]
	return num
}

func (s *State) generatePuzzle() {
	number_list := [9]int{1, 2, 3, 4, 5, 6, 7, 8, 9}
	for i := 0; i < rows; i++ {
		for j := 0; j < cols; j++ {
			if s.board[i][j] == 0 {
				num := generateNum()
				s.board[i][j] = num
				for element := range number_list {
					if s.isPossible(i, j, element) {
						s.board[i][j] = element
						s.generatePuzzle()
						s.board[i][j] = 0
					}
				}
			}
		}
	}
}

func (s *State) isPossible(y, x, n int) bool {
	for i := 0; i < rows; i++ {
		ynum := s.board[y][i]
		if ynum == n {
			return false
		}
	}
	for i := 0; i < cols; i++ {
		if s.board[i][x] == n {
			return false
		}
	}
	x0 := (x / 3) * 3
	y0 := (y / 3) * 3
	for i := 0; i < 3; i++ {
		for j := 0; j < 3; j++ {
			if s.board[y0+i][x0+j] == n {
				return false
			}
		}
	}
	return true
}

func (s *State) start() {
	s.generateEmpty()
	s.generatePuzzle()
	s.removeNumber
}

func (s *State) removeNumber() {
	// if easy select 20 elements out of matrix
	// if meidum select
}

func (s *State) placeNumber(row int, column int, value int) error {
	if row < 1 || column < 0 || row >= 10 || column >= 10 {
		return &positionOutOfBound{row, column}
	}
	if value < 1 || value >= 10 {
		return &valueNotValid{value}
	}
	if s.board[row][column] == originalNum {
		return &originalValue{value}
	}
	return nil
}

func (s *State) checkForWinner() string {
	for i := 0; i < rows; i++ {
		ynum := s.board[y][i]
		if ynum == n {
			return false
		}
	}
	for i := 0; i < cols; i++ {
		if s.board[i][x] == n {
			return false
		}
	}
	x0 := (x / 3) * 3
	y0 := (y / 3) * 3
	for i := 0; i < 3; i++ {
		for j := 0; j < 3; j++ {
			if s.board[y0+i][x0+j] == n {
				return false
			}
		}
	}
	return true
}
