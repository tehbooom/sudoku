package game

import (
	"fmt"
	"math/rand"
	"time"
)

const (
	cols = 9
	rows = 9
)

type State struct {
	board [cols][rows]int
}

type positionOutOfBound struct {
	row    int
	column int
}

type valueNotValid struct {
	value int
}

type originalValue struct {
	value int
}

func (e *positionOutOfBound) Error() string {
	return fmt.Sprintf("posistion (%d,%d) is out of bounds...", e.row, e.column)
}

func (e *valueNotValid) Error() string {
	return fmt.Sprintf("value %d is not 1-9", e.value)
}

func (e *originalValue) Error() string {
	return fmt.Sprintf("cannot modify an original value generated by the puzzle...", e.value)
}

func (s *State) Start() {
	s.generateEmpty()
	s.generatePuzzle()
	// s.removeNumber
}

func (s *State) generateEmpty() {
	for i := 0; i < rows; i++ {
		for j := 0; j < cols; j++ {
			s.board[i][j] = 0
		}

	}
}

func generateNum() int {
	number_list := [9]int{1, 2, 3, 4, 5, 6, 7, 8, 9}
	rand.Seed(time.Now().UnixNano())
	rlength := len(number_list)
	randomIndex := rand.Intn(rlength - 1)
	num := number_list[randomIndex]
	return num
}

func (s *State) generatePuzzle() {
	number_list := [9]int{1, 2, 3, 4, 5, 6, 7, 8, 9}
	for i := 0; i < rows; i++ {
		for j := 0; j < cols; j++ {
			if s.board[i][j] == 0 {
				s.board[i][j] = generateNum() // set random number in place
				for element := range number_list {
					if !s.isPossible(i, j, element) {
						s.board[i][j] = element
						s.generatePuzzle()
						s.board[i][j] = 0
					}
				}
			}
		}
	}
}

func (s *State) isPossible(y, x, n int) bool {

	// check to see if in row
	for i := 0; i < rows; i++ {
		if s.board[y][i] == n {
			return false
		}
	}

	// check to see if in column
	for i := 0; i < cols; i++ {
		if s.board[i][x] == n {
			return false
		}
	}

	// check to see if in square
	if y < 3 {
		if x < 3 { // Box 1
			for i := 0; i < 3; i++ {
				for j := 0; j < 3; j++ {
					if s.board[i][j] == n {
						return false
					}
				}
			}
		} else if x < 6 {
			for i := 0; i < 3; i++ {
				for j := 3; j < 6; j++ {
					if s.board[i][j] == n {
						return false
					}
				}
			}
		} else { // Box 3
			for i := 0; i < 3; i++ {
				for j := 6; j < 9; j++ {
					if s.board[i][j] == n {
						return false
					}
				}
			}
		}
	}
	if y < 6 {
		if x < 3 { // Box 4
			for i := 3; i < 6; i++ {
				for j := 0; j < 3; j++ {
					if s.board[i][j] == n {
						return false
					}
				}
			}
		} else if x < 6 { // Box 5
			for i := 3; i < 6; i++ {
				for j := 3; j < 6; j++ {
					if s.board[i][j] == n {
						return false
					}
				}
			}
		} else { // Box 6
			for i := 3; i < 6; i++ {
				for j := 6; j < 9; j++ {
					if s.board[i][j] == n {
						return false
					}
				}
			}
		}
	} else {
		if x < 3 { // Box 7
			for i := 6; i < 9; i++ {
				for j := 0; j < 3; j++ {
					if s.board[i][j] == n {
						return false
					}
				}
			}
		} else if x < 6 { // Box 8
			for i := 6; i < 9; i++ {
				for j := 3; j < 6; j++ {
					if s.board[i][j] == n {
						return false
					}
				}
			}
		} else { // Box 9
			for i := 6; i < 9; i++ {
				for j := 6; j < 9; j++ {
					if s.board[i][j] == n {
						return false
					}
				}
			}
		}
	}
	return true
}

func (s *State) placeNumber(row int, column int, value int) error {
	if row < 1 || column < 0 || row >= 10 || column >= 10 {
		return &positionOutOfBound{row, column}
	}
	if value < 1 || value >= 10 {
		return &valueNotValid{value}
	}
	if s.board[row][column] == FUNCTION THAT WILL BE SET AFTER WE REMOVE NUMBER {
		return &originalValue{value}
	}
	return nil
}

func (s *State) checkForWinner() string {
	// figure out a better way to check for winner
}
