package game

import (
	"fmt"
	"math/rand"
	"time"
)

const (
	cols = 9
	rows = 9
)

type State struct {
	board [cols][rows]int
}

type positionOutOfBound struct {
	row    int
	column int
}

type valueNotValid struct {
	value int
}

type originalValue struct {
	value int
}

func (e *positionOutOfBound) Error() string {
	return fmt.Sprintf("posistion (%d,%d) is out of bounds...", e.row, e.column)
}

func (e *valueNotValid) Error() string {
	return fmt.Sprintf("value %d is not 1-9", e.value)
}

func (e *originalValue) Error() string {
	return fmt.Sprintf("cannot modify an original value generated by the puzzle...", e.value)
}

func (s *State) generateEmpty() {

	for i := 0; i < rows; i++ {
		for j := 0; j < cols; j++ {
			s.board[i][j] = 0
		}

	}
}

func generateNum() int {
	number_list := [9]int{1, 2, 3, 4, 5, 6, 7, 8, 9}
	rand.Seed(time.Now().UnixNano())
	rlength := len(number_list)
	randomIndex := rand.Intn(rlength - 1)
	num := number_list[randomIndex]
	return num
}

func (s *State) generatePuzzle() {
	number_list := [9]int{1, 2, 3, 4, 5, 6, 7, 8, 9}
	for i := 0; i < rows; i++ {
		for j := 0; j < cols; j++ {
			if s.board[i][j] == 0 {
				num := generateNum()
				s.board[i][j] = num
				for element := range number_list {
					if s.isPossible(i, j, element) {
						s.board[i][j] = element
						s.generatePuzzle()
						s.board[i][j] = 0
					}
				}
			}
		}
	}
}

func (s *State) isPossible(y, x, n int) bool {
	for i := 0; i < rows; i++ {
		ynum := s.board[y][i]
		if ynum == n {
			return false
		}
	}
	for i := 0; i < cols; i++ {
		if s.board[i][x] == n {
			return false
		}
	}
	x0 := (x / 3) * 3
	y0 := (y / 3) * 3
	for i := 0; i < 3; i++ {
		for j := 0; j < 3; j++ {
			if s.board[y0+i][x0+j] == n {
				return false
			}
		}
	}
	return true
}

func (s *State) start() {
	s.generateEmpty()
	s.generatePuzzle()
	s.removeNumber
}

func (s *State) removeNumber() {
	// if easy select 20 elements out of matrix
	// if medium select
}

func (s *State) placeNumber(row int, column int, value int) error {
	if row < 1 || column < 0 || row >= 10 || column >= 10 {
		return &positionOutOfBound{row, column}
	}
	if value < 1 || value >= 10 {
		return &valueNotValid{value}
	}
	if s.board[row][column] == originalNum {
		return &originalValue{value}
	}
	return nil
}

func (s *State) checkForWinner() string {
	for i := 0; i < rows; i++ {
		ynum := s.board[y][i]
		if ynum == n {
			return false
		}
	}
	for i := 0; i < cols; i++ {
		if s.board[i][x] == n {
			return false
		}
	}
	x0 := (x / 3) * 3
	y0 := (y / 3) * 3
	for i := 0; i < 3; i++ {
		for j := 0; j < 3; j++ {
			if s.board[y0+i][x0+j] == n {
				return false
			}
		}
	}
	return true
}
